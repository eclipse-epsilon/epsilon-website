Model Disposal Tasks
--------------------

When a model is no longer required by tasks of the workflow, it can be
disposed using the *epsilon.disposeModel* task. The task provides the
*model* attribute that defines the name of the model to be disposed.
Also, the attribute-less *epsilon.disposeModels* task is provided that
disposes all the models in the project model repository. This task is
typically invoked when the model management part of the workflow has
finished.

Model Comparison Task
---------------------

The *epsilon.ecl* task executes an ECL module, defined using the *src*
attribute to establish matches between elements of the models that are
specified using the *model* nested elements. In addition to the
attributes defined by the ExecutableModuleTask, this task also provides
the *exportMatchTrace* attribute that enables users to export the
match-trace calculated during the comparison to the project context so
that subsequent tasks can reuse it. For example, as discussed in the
sequel, an EML model merging task can use it as a means of identifying
correspondences on which to perform merging. In another example, the
match-trace can be stored by a subsequent EOL task in the form of an
stand-alone weaving model.

Model-to-Text Transformation Task {#sec:EglTask}
---------------------------------

To support model to text transformations, *EglTask (epsilon.egl)* task
is provided that executes an Epsilon Generation Language (EGL)
module[^1]. In addition to the attributes defined by
*ExecutableModuleTask*, *EglTask* also defines the following attributes:

-   *target* : Defines a file in which all of the generated text will be
    stored.

-   *templateFactoryType* : Defines the Java class that will be
    instantiated to provide a *TemplateFactory* for the EGL program. The
    specified class must be on the classpath and must subtype
    *EglTemplateFactory*. See
    Section [\[sec:custom\_co-ordination\]](#sec:custom_co-ordination){reference-type="ref"
    reference="sec:custom_co-ordination"} for more information.

*EglTask* may nest any number of *formatter* elements. The *formatter*
nested element has the following attributes:

-   *implementation* (required) : Defines the Java class that will be
    instantiated to provide a *Formatter* for the EGL program. The
    specified class must be on the classpath and must subtype
    *Formatter*. See
    Section [\[sec:custom\_formatter\]](#sec:custom_formatter){reference-type="ref"
    reference="sec:custom_formatter"} for more information.

Model Merging Task
------------------

The *epsilon.eml* task executes an EML module, defined using the *src*
attribute on the models that are specified using the *model* nested
elements. In addition to the attributes defined by the
ExecutableModuleTask, this task also provides the following attributes:

-   *useMatchTrace* : As discussed in
    [\[sec:EML\]](#sec:EML){reference-type="ref" reference="sec:EML"},
    to merge a set of models, an EML module needs an established
    match-trace between elements of the models. The *useMatchTrace*
    attribute enables the EML task to use a match-trace exported by a
    preceeding ECL task (using its *exportMatchTrace* attribute).

-   *exportMergeTrace, exportTransformationTrace* : Similarly to ETL,
    through these attributes an EML task can export the internal traces
    calculated during merging for subsequent tasks to use.

Generic Model Management Task {#sec:EolTask}
-----------------------------

The *epsilon.eol* task executes an EOL module, defined using the *src*
attribute on the models that are specified using the *model* nested
elements.

Pattern Matching Task
---------------------

The *epsilon.epl* task executes an EPL module, defined using the *src*
attribute to perform pattern matching on the models that are specified
using the *model* nested elements. In addition to the attributes defined
by the ExecutableModuleTask, this task also provides the following
attributes.

-   *repeatWhileMatches*: A boolean specifying whether the pattern
    matching process should continue to execute for as long as matches
    are found.

-   *maxLoops*: An integer specifying the maximum number of pattern
    matching iterations.

-   *exportAs*: The name under which the computed pattern match model
    should be made available to other Epsilon tasks of the workflow.

The Abstract Executable Module Task {#sec:ExecutableModuleTask}
-----------------------------------

This task is the base of all the model management tasks presented in
Section
[\[sec:Workflow.ModelManagementTasks\]](#sec:Workflow.ModelManagementTasks){reference-type="ref"
reference="sec:Workflow.ModelManagementTasks"}. Its aim is to
encapsulate the commonalities of Epsilon tasks in order to reduce
duplication among them. As already discussed, in Epsilon, specifications
of model management tasks are organized in executable modules. While
modules can be stored anywhere, in the case of the workflow it is
assumed that they are either stored as separate files in the file-system
or they are provided inline within the worfklow. Thus, this abstract
task defines an *src* attribute that specifies the path of the source
file in which the Epsilon module is stored, but also supports inline
specification of the source of the module. The two alternatives are
demonstrated in Listings
[\[lst:External\]](#lst:External){reference-type="ref"
reference="lst:External"} and
[\[lst:Inline\]](#lst:Inline){reference-type="ref"
reference="lst:Inline"} respectively.

``` {#lst:External .xml basicstyle="\\ttfamily\\footnotesize" flexiblecolumns="true" numbers="none" nolol="true" caption="External Module Specification" label="lst:External" numbers="left" language="XML" tabsize="2"}
<project default="main">
    <target name="main">
        <epsilon.eol src="HelloWorld.eol"/>
    </target>
</project>
```

``` {#lst:Inline .xml basicstyle="\\ttfamily\\footnotesize" flexiblecolumns="true" numbers="none" nolol="true" caption="Inline Module Specification" label="lst:Inline" numbers="left" language="XML" tabsize="2"}
<project default="main">
    <target name="main">
        <epsilon.eol>
            <![CDATA[
                "Hello world".println();
            ]]>
        </epsilon.eol>
    </target>
</project>
```

Optionally, users can enable debugging for the module to be run by
setting the *debug* attribute to *true*. An example is shown in
Listing [\[lst:workflow-debug\]](#lst:workflow-debug){reference-type="ref"
reference="lst:workflow-debug"}. If the module reaches a breakpoint,
users will be able to run the code step by step and inspect the stack
trace and its variables.

``` {#lst:workflow-debug .xml basicstyle="\\ttfamily\\footnotesize" flexiblecolumns="true" numbers="none" nolol="true" caption="Inline Module Specification" label="lst:workflow-debug" numbers="left" language="XML" tabsize="2"}
<project default="main">
    <target name="main">
            <epsilon.eol src="HelloWorld.eol" debug="true"/>
        </target>
</project>
```

The task also defines the following nested elements:

#### 0..n $model$ nested elements

Through the *model* nested elements, each task can define which of the
models, loaded in the project repository it needs to access. Each
*model* element defines three attributes. The *ref* attribute specifies
the name of the model that the task needs to access, the *as* attribute
defines the name by which the model will be accessible in the context of
the task, and the *aliases* defines a comma-delimited sequence of
aliases for the model in the context of the task.

#### 0..n $parameter$ nested elements

The *parameter* nested elements enable users to communicate String
parameters to tasks. Each *parameter* element defines a *name* and a
*value* attribute. Before executing the module, each *parameter* element
is transformed into a String variable with the respective name and value
which is then made accessible to the module.

#### 0..n $exports$ nested elements

To facilitate low-level integration between different Epsilon tasks,
each task can export a number of variables to the project context, so
that subsequent tasks can access them later. Each *export* nested
element defines the three attributes. The *ref* attribute specifies the
name of the variable to be exported, the *as* string attribute defines
the name by which the variable is stored in the project context and the
*optional* boolean attribute specifies whether the variable is
mandatory. If *optional* is set to *false* and the module does not
specify such a variable, an ANT *BuildException* is raised.

#### 0..n $uses$ nested elements

The *uses* nested elements enable tasks to import variables exported by
previous Epsilon tasks. Each use element supports three attributes. The
*ref* attribute specifies the name of the variable to be used. If there
is no variable with this name in the project context, the ANT project
properties are queried. This enables Epsilon modules to access ANT
parameters (e.g. provided using command-line arguments). The *as*
attribute specifies the name by which the variable is accessible in the
context of the task. Finally, the *optional* boolean paramter specifies
if the variable must exist in the project context.

To better illustrate the runtime communication mechanism, a minimal
example is provided in Listings
[\[lst:Exporter\]](#lst:Exporter){reference-type="ref"
reference="lst:Exporter"} -
[\[lst:ExporterUserWorkflow\]](#lst:ExporterUserWorkflow){reference-type="ref"
reference="lst:ExporterUserWorkflow"}. In Listing
[\[lst:Exporter\]](#lst:Exporter){reference-type="ref"
reference="lst:Exporter"}, *Exporter.eol* defines a String variable
named *x* and assigns a value to it. The workflow of Listing
[\[lst:ExporterUserWorkflow\]](#lst:ExporterUserWorkflow){reference-type="ref"
reference="lst:ExporterUserWorkflow"} specifies that after executing
*Exporter.eol*, it must export a variable named *x* with the new name
*y* to the project context. Finally, it defines that before executing
*User.eol* (Listing [\[lst:User\]](#lst:User){reference-type="ref"
reference="lst:User"}), it must query the project context for a variable
named *y* and in case this is available, add the variable to the
module's context and then execute it. Thus, the result of executing the
workflow is *Some String* printed in the output console.

``` {#lst:Exporter .EOL basicstyle="\\ttfamily\\footnotesize" nolol="true" flexiblecolumns="true" caption="Source code of the Exporter.eol module" label="lst:Exporter" language="EOL"}
var x : String = "Some string";
```

``` {#lst:User .EOL basicstyle="\\ttfamily\\footnotesize" nolol="true" flexiblecolumns="true" caption="Source code of the User.eol module" label="lst:User" language="EOL"}
z.println();
```

``` {#lst:ExporterUserWorkflow .xml basicstyle="\\ttfamily\\footnotesize" nolol="true" flexiblecolumns="true" caption="ANT Workflow connecting modules  \\ref{lst:Exporter} and \\ref{lst:User} using the epsilon.eol task" label="lst:ExporterUserWorkflow" language="XML"}
<epsilon.eol src="Exporter.eol">
    <exports ref="x" as="y"/>
</epsilon.eol>

<epsilon.eol src="User.eol">
    <uses ref="y" as="z"/>
</epsilon.eol>
```

Model-to-Model Transformation Task
----------------------------------

The *epsilon.etl* task executes an ETL module, defined using the *src*
attribute to transform between the models that are specified using the
*model* nested elements. In addition to the attributes defined by the
ExecutableModuleTask, this task also provides the
*exportTransformationTrace* attribute that enables the developer to
export the internal transformation trace to the project context. In this
way this trace can be reused by subsequent tasks; for example another
task can serialize it in the form of a separate traceability model.

Model Validation Task {#sec:EvlTask}
---------------------

The *epsilon.evl* task executes an EVL module, defined using the *src*
attribute on the models that are specified using the *model* nested
elements. In addition to the attributes defined by the
ExecutableModuleTask, this task also provides the following attributes:

-   *failOnErrors* : Errors are the results of unsatisfied constraints.
    Setting the value of this attribute to *true* (default is *false*)
    causes a *BuildException* to be raised if one or more errors are
    identified during the validation process.

-   *failOnWarnings* : Similarly to errors, warnings are the results of
    unsatisfied critiques. Setting the value of this atrribute to *true*
    (default is also *false*) causes a *BuildException* to be raised if
    one or more warnings are identified during the validation process.

-   *exportConstraintTrace* : This attribute enables developers to
    export the internal constraint trace constructed during model
    validation to the project context so that it can be later accessed
    by other tasks - which could for example attempt to automatically
    repair the identified inconsistencies.

-   *exportAsModel* : Setting the value of this attribute to *true*
    (default is *false*) causes EVL to export the results of the
    validation as a new model in the project repository, named "EVL".
    This model contains all the s found by EVL. These instances contain
    several useful attributes: *constraint* points to the with the
    definition of the constraint and *instance* points to the model
    element which did not satisfy the constraint. From the ,
    *isCritique* can be used to check if it is a critique or not, and
    *name* contains the name of the constraint.

Model Migration Task {#sec:FlockTask}
--------------------

To support model migration, *FlockTask (epsilon.flock)* is provided for
executing an Epsilon Flock module
(Chapter [\[sec:Flock\]](#sec:Flock){reference-type="ref"
reference="sec:Flock"}). In addition to the attributes defined by
*ExecutableModuleTask*, *FlockTask* also defines the following mandatory
attributes:

-   *originalModel* : Specifies which of the currently loaded models
    should be used as the source of the model migration.

-   *migratedModel* : Specifies which of the currently loaded models
    should be used as the target of the model migration.

Model Loading Tasks
-------------------

The *LoadModelTask (epsilon.loadModel)* loads a model from an arbitrary
location (e.g. file-system, database) and adds it to the project
repository so that subsequent Epsilon tasks can query or modify it.
Since Epsilon supports many modelling technologies (e.g. EMF, MDR, XML),
the *LoadModelTask* defines only three generic attributes. The *name*
attribute specifies the name of the model in the project repository. The
*type* attribute specifies the modelling technology with which the model
is captured and is used to resolve the technology-specific model loading
functionality. Finally, the *aliases* attribute defines a
comma-separated list of alternative names by which the model can be
accessed in the model repository.

The rest of the information needed to load a model is
implementation-specific and is therefore provided through *parameter*
nested elements, each one defining a pair of *name*-*value* attributes.
As an example, a task for loading an EMF model that has a file-based
ECore metamodel is displayed in Listing
[\[lst:LoadModelTask\]](#lst:LoadModelTask){reference-type="ref"
reference="lst:LoadModelTask"}.

``` {#lst:LoadModelTask .xml basicstyle="\\ttfamily\\footnotesize" nolol="true" flexiblecolumns="true" caption="Loading an EMF model using the epsilon.loadModel task" label="lst:LoadModelTask" language="XML"}
<epsilon.loadModel name="Tree1" type="EMF">
    <parameter name="modelFile" value="TreeInstance.ecore"/>
    <parameter name="metamodelFile" path="Tree.ecore"/>
    <parameter name="isMetamodelFileBased" value="true"/>
    <parameter name="readOnLoad" value="true"/>
</epsilon.loadModel>
```

*LoadEmfModelTask* is a specialised version of *LoadModelTask* only for
EMF models. While the *type* attribute is no longer available, the task
still supports the *name* and *aliases* attributes. In addition, some of
the values which had to be provided through *parameter* nested elements
can now be set using regular attributes, such as *modelFile*,
*modelUri*, *metamodelFile* (which implicitly indicates that the
metamodel is file-based), *metamodelUri*, *reuseUnmodifiedMetamodelFile*
(which can be set to "false" to avoid reusing file-based metamodels that
have not been modified since the last time they were loaded), *read*
(equivalent to *readOnLoad*) and *store* (equivalent to
*storeOnDisposal*).
Listing [\[lst:LoadEmfModelTask\]](#lst:LoadEmfModelTask){reference-type="ref"
reference="lst:LoadEmfModelTask"} shows the equivalent fragment required
to produce the same result as in
Listing [\[lst:LoadModelTask\]](#lst:LoadModelTask){reference-type="ref"
reference="lst:LoadModelTask"}.

``` {#lst:LoadEmfModelTask .xml float="tbp" basicstyle="\\ttfamily\\footnotesize" nolol="true" flexiblecolumns="true" caption="Loading an EMF model using the epsilon.emf.loadModel task" label="lst:LoadEmfModelTask" language="XML"}
<epsilon.emf.loadModel name="Tree1"
  modelFile="TreeInstance.ecore"
  metamodelFile="Tree.ecore" />
```

Model Storing Task
------------------

The *StoreModelTask (epsilon.storeModel)* is used to store a model
residing in the project repository. The *StoreModelTask* defines three
attributes:

-   *name* (required): name of the model to be stored.

-   *targetUri* (optional): URI where the model will be stored (e.g.
    "file:/path/to/destination").

-   *target* (optional): file path where the model will be stored (e.g.
    "file.xmi").

*targetUri* takes precedence over *target*. If neither is defined, then
the model is stored in the location from which it was originally loaded.

[^1]: As discussed in Section
    [\[sec:EGL\]](#sec:EGL){reference-type="ref" reference="sec:EGL"}
    EGL has been built atop Epsilon with a minimal contribution of the
    author
